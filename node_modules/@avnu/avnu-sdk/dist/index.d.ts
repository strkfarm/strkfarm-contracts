import { Call, Signature, TypedData, AccountInterface } from 'starknet';

declare const SEPOLIA_BASE_URL = "https://sepolia.api.avnu.fi";
declare const BASE_URL = "https://starknet.api.avnu.fi";

interface Pageable {
    page?: number;
    size?: number;
    sort?: string;
}
type GetTokensRequest = Pageable;
interface Page<T> {
    content: T[];
    totalPages: number;
    totalElements: number;
    size: number;
    number: number;
}
interface Token {
    name: string;
    address: string;
    symbol: string;
    decimals: number;
    chainId: string;
    logoUri: string;
}
interface PriceRequest {
    sellTokenAddress: string;
    buyTokenAddress: string;
    sellAmount: bigint;
}
interface QuoteRequest {
    sellTokenAddress: string;
    buyTokenAddress: string;
    sellAmount?: bigint;
    buyAmount?: bigint;
    takerAddress?: string;
    size?: number;
    excludeSources?: string[];
    integratorFees?: bigint;
    integratorFeeRecipient?: string;
    integratorName?: string;
}
interface Route {
    name: string;
    address: string;
    percent: number;
    sellTokenAddress: string;
    buyTokenAddress: string;
    routeInfo?: Map<string, string>;
    routes: Route[];
}
interface Price {
    sellTokenAddress: string;
    sellAmount: bigint;
    sellAmountInUsd: number;
    buyTokenAddress: string;
    buyAmount: bigint;
    buyAmountInUsd: number;
    blockNumber?: number;
    chainId: string;
    sourceName: string;
    priceRatioUsd: number;
    gasFees: bigint;
    gasFeesInUsd: number;
}
interface Quote {
    quoteId: string;
    sellTokenAddress: string;
    sellAmount: bigint;
    sellAmountInUsd: number;
    buyTokenAddress: string;
    buyAmount: bigint;
    buyAmountInUsd: number;
    buyAmountWithoutFees: bigint;
    buyAmountWithoutFeesInUsd: number;
    blockNumber?: number;
    chainId: string;
    expiry?: number;
    routes: Route[];
    gasFees: bigint;
    gasFeesInUsd: number;
    avnuFees: bigint;
    avnuFeesInUsd: number;
    avnuFeesBps: bigint;
    integratorFees: bigint;
    integratorFeesInUsd: number;
    integratorFeesBps: bigint;
    priceRatioUsd: number;
    sellTokenPriceInUsd?: number;
    buyTokenPriceInUsd?: number;
    liquiditySource: 'DEX_AGGREGATOR' | 'MARKET_MAKER' | 'SOLVER';
    gasless: Gasless;
}
interface Gasless {
    active: boolean;
    gasTokenPrices: {
        tokenAddress: string;
        gasFeesInUsd: number;
        gasFeesInGasToken: bigint;
    }[];
}
interface InvokeSwapResponse {
    transactionHash: string;
    gasTokenAddress?: string;
    gasTokenAmount?: bigint;
}
interface RequestError {
    messages: string[];
    revertError: string | undefined;
}
interface AvnuOptions {
    baseUrl?: string;
    abortSignal?: AbortSignal;
    avnuPublicKey?: string;
}
interface ExecuteSwapOptions {
    executeApprove?: boolean;
    gasless?: boolean;
    gasTokenAddress?: string;
    maxGasTokenAmount?: bigint;
    slippage?: number;
    executeGaslessTxCallback?: () => unknown;
}
interface BuildSwapTransaction {
    chainId: string;
    calls: Call[];
}
declare enum SourceType {
    DEX = "DEX",
    MARKET_MAKER = "MARKET_MAKER",
    SOLVER = "SOLVER"
}
interface Source {
    name: string;
    address: string;
    icon?: string;
    type: SourceType;
}
declare class ContractError {
    message: string;
    revertError: string;
    constructor(message: string, revertError: string);
}

declare const aPriceRequest: () => PriceRequest;
declare const aQuoteRequest: () => QuoteRequest;
declare const aPrice: () => Price;
declare const aQuote: () => Quote;
declare const aQuoteWithManySubRoutes: () => Quote;
declare const aQuoteWithManyComplexRoutes: () => Quote;
declare const anInvokeSwapResponse: () => InvokeSwapResponse;
declare const aBuildSwapTransaction: () => BuildSwapTransaction;
declare const ethToken: () => Token;
declare const btcToken: () => Token;
declare const aPage: <T>(content: T[], size?: number, number?: number, totalPages?: number, totalElements?: number) => Page<T>;
declare const aSource: () => Source;

/**
 * Fetches the prices of DEX applications.
 * It allows to find the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices are sorted (best first).
 *
 * @returns The best quotes
 * @param request The request params for the avnu API `/swap/v2/prices` endpoint.
 * @param options Optional options.
 */
declare const fetchPrices: (request: PriceRequest, options?: AvnuOptions) => Promise<Price[]>;
/**
 * Fetches the best quotes.
 * It allows to find the best quotes from on-chain and off-chain liquidity. The best quotes will be returned and are sorted (best first).
 *
 * @param request The request params for the avnu API `/swap/v2/quotes` endpoint.
 * @param options Optional options.
 * @returns The best quotes
 */
declare const fetchQuotes: (request: QuoteRequest, options?: AvnuOptions) => Promise<Quote[]>;
/**
 * Executing the exchange through AVNU router
 *
 * @param quoteId The id of the selected quote
 * @param signature The typed data's signature
 * @param options Optional options.
 * @returns The transaction hash
 */
declare const fetchExecuteSwapTransaction: (quoteId: string, signature: Signature, options?: AvnuOptions) => Promise<InvokeSwapResponse>;
/**
 * Build data for executing the exchange through AVNU router
 * It allows trader to build the data needed for executing the exchange on AVNU router
 *
 * @param quoteId The id of the selected quote
 * @param takerAddress Required when taker address was not provided during the quote request
 * @param slippage The maximum acceptable slippage of the buyAmount amount. Default value is 5%. 0.05 is 5%.
 * This value is ignored if slippage is not applicable to the selected quote
 * @param includeApprove If true, the response will contain the approve call. True by default.
 * @param options Optional options.
 * @returns The calldata
 */
declare const fetchBuildExecuteTransaction: (quoteId: string, takerAddress?: string, slippage?: number, includeApprove?: boolean, options?: AvnuOptions) => Promise<BuildSwapTransaction>;
/**
 * Build typed-data. Once signed by the user, the signature can be sent to the API to be executed by AVNU
 *
 * @param quoteId The id of the selected quote
 * @param gasTokenAddress The gas token address that will be used to pay the gas fees
 * @param maxGasTokenAmount The maximum amount of gas token the user accepts to spend
 * @param includeApprove If true, the typed data will contains the approve call
 * @param takerAddress Required when taker address was not provided during the quote request
 * @param slippage The maximum acceptable slippage of the buyAmount amount. Default value is 5%. 0.05 is 5%.
 * This value is ignored if slippage is not applicable to the selected quote
 * @param options Optional options.
 * @returns The calldata
 */
declare const fetchBuildSwapTypedData: (quoteId: string, gasTokenAddress: string, maxGasTokenAmount: bigint, includeApprove?: boolean, takerAddress?: string, slippage?: number, options?: AvnuOptions) => Promise<TypedData>;
/**
 * Fetches the supported tokens.
 *
 * @param request The request params for the avnu API `/swap/v2/tokens` endpoint.
 * @param options Optional options.
 * @returns The best quotes
 */
declare const fetchTokens: (request?: GetTokensRequest, options?: AvnuOptions) => Promise<Page<Token>>;
/**
 * Fetches the supported sources
 *
 * @param options Optional options.
 * @returns The sources
 */
declare const fetchSources: (options?: AvnuOptions) => Promise<Source[]>;
/**
 * Execute the exchange
 *
 * @param account The account of the trader
 * @param quote The selected quote. See `getQuotes`
 * @param executeApprove False if the taker already executed `approve`
 * @param gasless False if the user wants to execute the transaction himself
 * @param gasTokenAddress The gas token address that will be used to pay the gas fees (required when gasless is true)
 * @param maxGasTokenAmount The maximum amount of gas token that the user is willing to spend (required when gasless is true)
 * @param executeGaslessTxCallback This function is called after the user signed the typed data and just before calling the API to execute the transaction
 * @param slippage The maximum acceptable slippage of the buyAmount amount. Default value is 5%. 0.05 is 5%.
 * This value is ignored if slippage is not applicable to the selected quote
 * @param options Optional options.
 * @returns Promise<InvokeSwapResponse>
 */
declare const executeSwap: (account: AccountInterface, quote: Quote, { executeApprove, gasless, gasTokenAddress, maxGasTokenAmount, slippage, executeGaslessTxCallback, }?: ExecuteSwapOptions, options?: AvnuOptions) => Promise<InvokeSwapResponse>;
/**
 * Calculate the min amount received from amount and slippage
 *
 * @param amount The amount to apply slippage
 * @param slippage The slippage to apply in bps. 10 is 0.1%
 * @returns bigint
 */
declare const calculateMinAmount: (amount: bigint, slippage: number) => bigint;

export { type AvnuOptions, BASE_URL, type BuildSwapTransaction, ContractError, type ExecuteSwapOptions, type Gasless, type GetTokensRequest, type InvokeSwapResponse, type Page, type Pageable, type Price, type PriceRequest, type Quote, type QuoteRequest, type RequestError, type Route, SEPOLIA_BASE_URL, type Source, SourceType, type Token, aBuildSwapTransaction, aPage, aPrice, aPriceRequest, aQuote, aQuoteRequest, aQuoteWithManyComplexRoutes, aQuoteWithManySubRoutes, aSource, anInvokeSwapResponse, btcToken, calculateMinAmount, ethToken, executeSwap, fetchBuildExecuteTransaction, fetchBuildSwapTypedData, fetchExecuteSwapTransaction, fetchPrices, fetchQuotes, fetchSources, fetchTokens };
